#include <stdio.h>
#include <string.h>
#include <conio.h>
#include <stdlib.h>
#include <windows.h>

#define INFINITY 9999999
// Аналог нескінченності

#define V 5
// Кількість вершин графа

int G[V][V] = {
  {0, 1, 0, 0, 1},
  {1, 0, 2, 0, 2},
  {0, 2, 0, 2, 3},
  {0, 0, 2, 0, 3},
  {1, 2, 3, 3, 0} }; // Матриця суміжності для графа розміру 5х5

int G1[V][V] = {
  {0, -1, 0, 0, -1},
  {-1, 0, -2, 0, -2},
  {0, -2, 0, -2, -3},
  {0, 0, -2, 0, -3},
  {-1, -2, -3, -3, 0} };

int main()
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    int choice;
    printf("Створення програми, що реалізує алгоритм Пріма (найближчого сусіда) знаходження кістякового дерева екстремальної(найбільшої або найменшої) ваги для довільного скінченого неорієнтованого зв’язаного графа.");
    printf("\n1. Мінімальна вага графа\n2. Максимальна вага графа: \n");
    printf("Виберіть режим роботи програми: ");
    scanf_s("%d", &choice);
    if (choice == 1) {
       printf("\nМінімальна вага графа\n");
        int numofEdge;  // Номер вершини графа

        int selected[V]; // Масив для вибраних вершин (стають true)

        memset(selected, false, sizeof(selected)); // Всім selected ставить початкове значення false

        numofEdge = 0; // Початкова кількість вершин дорівнює 0

        // Кількість ребер є меншим ніж (V-1), де V - кількість вершин графа

        selected[0] = true; // Значення true для початкового елемента

        int x;  //  Номер рядка    
        int y;  //  Номер стовпця
        int SUM = 0;

       printf("Ребра: Вага\n\n");
        while (numofEdge < V - 1) {

            //Для кожної вершини знайти суміжні з нею вершини і обчислити відстань між ними. Якщо вершинавжеє true, товідмінитиїї; інакше - вибрати іншу вершину, яка є найближчою до вибраної вершини.

            int min = INFINITY;
            x = 0;
            y = 0;


            for (int i = 0; i < V; i++) {
                if (selected[i]) {
                    for (int j = 0; j < V; j++) {
                        if (!selected[j] && G[i][j]) {  // Невибрана, але має ребро
                            if (min > G[i][j]) {
                                min = G[i][j];
                                x = i;
                                y = j;
                            }
                        }
                    }
                }
            }
            printf("%d - %d : %d\n", x + 1, y + 1, G[x][y]);
            
            SUM += G[x][y];
            selected[y] = true;
            numofEdge++;
        }
        printf("\nЗагальна вага(мінімальна): %d\n", SUM);
        
    }
    if (choice == 2) {
        printf("\nМаксимальна вага графа\n");
        int numofEdge;  // Номер вершини графа

        int selected[V]; // Масив для вибраних вершин (стаютьtrue)

        memset(selected, false, sizeof(selected)); // Всім selected ставить початкове значення false

        numofEdge = 0; // Початкова кількість вершин дорівнює 0

        // Кількість ребер є меншим ніж (V-1), де V - кількість вершин графа

        selected[0] = true; // Значення true для початкового елемента

        int x;  //  Номер рядка    
        int y;  //  Номер стовпця
        int SUM = 0;

        printf("Ребра: Вага\n\n");
        

        while (numofEdge < V - 1) {

            //Для кожної вершини знайти суміжні з нею вершини і обчислити відстань між ними. Якщо вершинавжеє true, товідмінитиїї; інакше - вибрати іншу вершину, яка є найближчою до вибраної вершини.

            int min = INFINITY;
            x = 0;
            y = 0;


            for (int i = 0; i < V; i++) {
                if (selected[i]) {
                    for (int j = 0; j < V; j++) {
                        if (!selected[j] && G1[i][j]) {  // Невибрана, але має ребро
                            if (min > G1[i][j]) {
                                min = G1[i][j];
                                x = i;
                                y = j;
                            }
                        }
                    }
                }
            }
            printf("%d - %d : %d\n", x + 1, y + 1, G[x][y]);
            

            SUM += abs(G1[x][y]);
            selected[y] = true;
            numofEdge++;
        }
        printf("\nЗагальна вага(максимальна): %d\n", abs(SUM));
    }

    return 0;
}
